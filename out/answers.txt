<s> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import tabs <EOL> class NetworkProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> def get_context_data ( self , request ) : <EOL> return None <EOL> class PolicyProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> preload = False <EOL> class IndexTabs ( tabs . TabGroup ) : <EOL> slug = "<STR_LIT>" <EOL> tabs = ( NetworkProfileTab , PolicyProfileTab ) </s>
<s> """<STR_LIT>""" <EOL> import weakref <EOL> from eventlet import corolocal <EOL> class WeakLocal ( corolocal . local ) : <EOL> def __getattribute__ ( self , attr ) : <EOL> rval = corolocal . local . __getattribute__ ( self , attr ) <EOL> if rval : <EOL> rval = rval ( ) <EOL> return rval <EOL> def __setattr__ ( self , attr , value ) : <EOL> value = weakref . ref ( value ) <EOL> return corolocal . local . __setattr__ ( self , attr , value ) <EOL> store = WeakLocal ( ) <EOL> weak_store = WeakLocal ( ) <EOL> strong_store = corolocal . local </s>
<s> import eventlet <EOL> eventlet . monkey_patch ( ) <EOL> import contextlib <EOL> import sys <EOL> from oslo . config import cfg <EOL> from openstack_dashboard . openstack . common import log as logging <EOL> from openstack_dashboard . openstack . common import rpc <EOL> from openstack_dashboard . openstack . common . rpc import impl_zmq <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( rpc . rpc_opts ) <EOL> CONF . register_opts ( impl_zmq . zmq_opts ) <EOL> def main ( ) : <EOL> CONF ( sys . argv [ <NUM_LIT:1> : ] , project = '<STR_LIT>' ) <EOL> logging . setup ( "<STR_LIT>" ) <EOL> with contextlib . closing ( impl_zmq . ZmqProxy ( CONF ) ) as reactor : <EOL> reactor . consume_in_thread ( ) <EOL> reactor . wait ( ) </s>
<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 import client <EOL> neutronclient = client . Client <EOL> class VPNaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_create ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : vpnservice1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : vpnservice1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] <EOL> } <EOL> vpnservice = { '<STR_LIT>' : self . api_vpnservices . first ( ) } <EOL> neutronclient . create_vpnservice ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservices_get ( self ) : <EOL> vpnservices = { '<STR_LIT>' : self . vpnservices . list ( ) } <EOL> vpnservices_dict = { '<STR_LIT>' : self . api_vpnservices . list ( ) } <EOL> neutronclient . list_vpnservices ( ) . AndReturn ( vpnservices_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservices_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , vpnservices [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . VPNService ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_get ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> vpnservice = { '<STR_LIT>' : vpnservice1 } <EOL> neutronclient . show_vpnservice ( <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_get ( self . request , <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_create ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ikepolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ikepolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ikepolicy = { '<STR_LIT>' : self . api_ikepolicies . first ( ) } <EOL> neutronclient . create_ikepolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicies_get ( self ) : <EOL> ikepolicies = { '<STR_LIT>' : self . ikepolicies . list ( ) } <EOL> ikepolicies_dict = { '<STR_LIT>' : self . api_ikepolicies . list ( ) } <EOL> neutronclient . list_ikepolicies ( ) . AndReturn ( ikepolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ikepolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IKEPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_get ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> ikepolicy = { '<STR_LIT>' : ikepolicy1 } <EOL> neutronclient . show_ikepolicy ( <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_get ( self . request , <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_create ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecpolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecpolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecpolicy = { '<STR_LIT>' : self . api_ipsecpolicies . first ( ) } <EOL> neutronclient . create_ipsecpolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicies_get ( self ) : <EOL> ipsecpolicies = { '<STR_LIT>' : self . ipsecpolicies . list ( ) } <EOL> ipsecpolicies_dict = { '<STR_LIT>' : self . api_ipsecpolicies . list ( ) } <EOL> neutronclient . list_ipsecpolicies ( ) . AndReturn ( ipsecpolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ipsecpolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_get ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> ipsecpolicy = { '<STR_LIT>' : ipsecpolicy1 } <EOL> neutronclient . show_ipsecpolicy ( <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_get ( self . request , <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_create ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecsiteconnection1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecsiteconnection1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecsiteconnection = { '<STR_LIT>' : <EOL> self . api_ipsecsiteconnections . first ( ) } <EOL> neutronclient . create_ipsec_site_connection ( <EOL> { '<STR_LIT>' : <EOL> form_data } ) . AndReturn ( ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_create ( <EOL> self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnections_get ( self ) : <EOL> ipsecsiteconnections = { <EOL> '<STR_LIT>' : self . ipsecsiteconnections . list ( ) } <EOL> ipsecsiteconnections_dict = { <EOL> '<STR_LIT>' : self . api_ipsecsiteconnections . list ( ) } <EOL> neutronclient . list_ipsec_site_connections ( ) . AndReturn ( <EOL> ipsecsiteconnections_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnections_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , <EOL> ipsecsiteconnections [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecSiteConnection ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_get ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> ipsecsiteconnection = { '<STR_LIT>' : ipsecsiteconnection1 } <EOL> neutronclient . show_ipsec_site_connection ( <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( <EOL> ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_get ( self . request , <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) </s>
<s> from horizon import tables <EOL> from openstack_dashboard . usage import base <EOL> class UsageView ( tables . DataTableView ) : <EOL> usage_class = None <EOL> show_terminated = True <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( UsageView , self ) . __init__ ( * args , ** kwargs ) <EOL> if not issubclass ( self . usage_class , base . BaseUsage ) : <EOL> raise AttributeError ( "<STR_LIT>" <EOL> "<STR_LIT>" ) <EOL> def get_template_names ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT:.>" . join ( ( self . template_name . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> return self . template_name <EOL> def get_content_type ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT>" <EOL> return "<STR_LIT>" <EOL> def get_data ( self ) : <EOL> project_id = self . kwargs . get ( '<STR_LIT>' , self . request . user . tenant_id ) <EOL> self . usage = self . usage_class ( self . request , project_id ) <EOL> self . usage . summarize ( * self . usage . get_date_range ( ) ) <EOL> self . usage . get_limits ( ) <EOL> self . kwargs [ '<STR_LIT>' ] = self . usage <EOL> return self . usage . usage_list <EOL> def get_context_data ( self , ** kwargs ) : <EOL> context = super ( UsageView , self ) . get_context_data ( ** kwargs ) <EOL> context [ '<STR_LIT>' ] . kwargs [ '<STR_LIT>' ] = self . usage <EOL> context [ '<STR_LIT>' ] = self . usage . form <EOL> context [ '<STR_LIT>' ] = self . usage <EOL> return context <EOL> def render_to_response ( self , context , ** response_kwargs ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> render_class = self . csv_response_class <EOL> response_kwargs . setdefault ( "<STR_LIT:filename>" , "<STR_LIT>" ) <EOL> else : <EOL> render_class = self . response_class <EOL> resp = render_class ( request = self . request , <EOL> template = self . get_template_names ( ) , <EOL> context = context , <EOL> content_type = self . get_content_type ( ) , <EOL> ** response_kwargs ) <EOL> return resp </s>
<s> from enum import IntEnum <EOL> from . component import Component <EOL> from . object import field <EOL> class ReflectionProbeUsage ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> BlendProbes = <NUM_LIT:1> <EOL> BlendProbesAndSkybox = <NUM_LIT:2> <EOL> Simple = <NUM_LIT:3> <EOL> class ShadowCastingMode ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> On = <NUM_LIT:1> <EOL> TwoSided = <NUM_LIT:2> <EOL> ShadowsOnly = <NUM_LIT:3> <EOL> class Renderer ( Component ) : <EOL> enabled = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index = field ( "<STR_LIT>" ) <EOL> materials = field ( "<STR_LIT>" ) <EOL> probe_anchor = field ( "<STR_LIT>" ) <EOL> receive_shadows = field ( "<STR_LIT>" , bool ) <EOL> reflection_probe_usage = field ( "<STR_LIT>" , ReflectionProbeUsage ) <EOL> shadow_casting_mode = field ( "<STR_LIT>" , ShadowCastingMode ) <EOL> sorting_layer_id = field ( "<STR_LIT>" ) <EOL> sorting_order = field ( "<STR_LIT>" ) <EOL> use_light_probes = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index_dynamic = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset_dynamic = field ( "<STR_LIT>" ) <EOL> static_batch_root = field ( "<STR_LIT>" ) <EOL> subset_indices = field ( "<STR_LIT>" ) <EOL> @ property <EOL> def material ( self ) : <EOL> return self . materials [ <NUM_LIT:0> ] <EOL> class ParticleSystemRenderMode ( IntEnum ) : <EOL> Billboard = <NUM_LIT:0> <EOL> Stretch = <NUM_LIT:1> <EOL> HorizontalBillboard = <NUM_LIT:2> <EOL> VerticalBillboard = <NUM_LIT:3> <EOL> Mesh = <NUM_LIT:4> <EOL> class ParticleSystemSortMode ( IntEnum ) : <EOL> None_ = <NUM_LIT:0> <EOL> Distance = <NUM_LIT:1> <EOL> OldestInFront = <NUM_LIT:2> <EOL> YoungestInFront = <NUM_LIT:3> <EOL> class MeshRenderer ( Component ) : <EOL> pass <EOL> class ParticleRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) <EOL> stretch_particles = field ( "<STR_LIT>" ) <EOL> uv_animation = field ( "<STR_LIT>" ) <EOL> class ParticleSystemRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> mesh = field ( "<STR_LIT>" ) <EOL> mesh1 = field ( "<STR_LIT>" ) <EOL> mesh2 = field ( "<STR_LIT>" ) <EOL> mesh3 = field ( "<STR_LIT>" ) <EOL> normal_direction = field ( "<STR_LIT>" ) <EOL> render_mode = field ( "<STR_LIT>" , ParticleSystemRenderMode ) <EOL> sort_mode = field ( "<STR_LIT>" , ParticleSystemSortMode ) <EOL> sorting_fudge = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) </s>
<s> from ConfigParser import * <EOL> from StringIO import * <EOL> from Log import Log <EOL> import datetime <EOL> class Config : <EOL> @ staticmethod <EOL> def LoadConfig ( ) : <EOL> Config . parser = ConfigParser ( ) <EOL> try : <EOL> sconff = open ( CONFIG_FILE , "<STR_LIT:r>" ) <EOL> except : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> return <EOL> sconf = StringIO ( ) <EOL> sconf . write ( "<STR_LIT>" ) <EOL> sconf . write ( sconff . read ( ) ) <EOL> sconf . seek ( <NUM_LIT:0> ) <EOL> Config . parser . readfp ( sconf ) <EOL> sconff . close ( ) <EOL> sconf . close ( ) <EOL> return <EOL> @ staticmethod <EOL> def GetBoardsFile ( ) : <EOL> return BOARDS_FILE <EOL> @ staticmethod <EOL> def GetInt ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> return Config . parser . getint ( '<STR_LIT>' , name ) <EOL> else : <EOL> return defval <EOL> @ staticmethod <EOL> def GetString ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> val = Config . parser . get ( '<STR_LIT>' , name ) <EOL> if ( val [ <NUM_LIT:0> ] == '<STR_LIT:">' and val . endswith ( '<STR_LIT:">' ) ) : <EOL> val = val [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> return val . decode ( '<STR_LIT>' ) <EOL> else : <EOL> return defval <EOL> BBS_ROOT = '<STR_LIT>' <EOL> BBS_XMPP_CERT_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BBS_XMPP_KEY_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BOARDS_FILE = BBS_ROOT + '<STR_LIT>' <EOL> STRLEN = <NUM_LIT> <EOL> ARTICLE_TITLE_LEN = <NUM_LIT> <EOL> BM_LEN = <NUM_LIT> <EOL> MAXBOARD = <NUM_LIT> <EOL> CONFIG_FILE = BBS_ROOT + '<STR_LIT>' <EOL> FILENAME_LEN = <NUM_LIT:20> <EOL> OWNER_LEN = <NUM_LIT:30> <EOL> SESSIONID_LEN = <NUM_LIT:32> <EOL> REFRESH_TOKEN_LEN = <NUM_LIT> <EOL> NAMELEN = <NUM_LIT> <EOL> IDLEN = <NUM_LIT:12> <EOL> MD5PASSLEN = <NUM_LIT:16> <EOL> OLDPASSLEN = <NUM_LIT> <EOL> MOBILE_NUMBER_LEN = <NUM_LIT> <EOL> MAXCLUB = <NUM_LIT> <EOL> MAXUSERS = <NUM_LIT> <EOL> MAX_MSG_SIZE = <NUM_LIT> <EOL> MAXFRIENDS = <NUM_LIT> <EOL> MAXMESSAGE = <NUM_LIT:5> <EOL> MAXSIGLINES = <NUM_LIT:6> <EOL> IPLEN = <NUM_LIT:16> <EOL> DEFAULTBOARD = "<STR_LIT>" <EOL> BLESS_BOARD = "<STR_LIT>" <EOL> QUOTED_LINES = <NUM_LIT:10> <EOL> MAXACTIVE = <NUM_LIT> <EOL> USHM_SIZE = MAXACTIVE + <NUM_LIT:10> <EOL> UTMP_HASHSIZE = USHM_SIZE * <NUM_LIT:4> <EOL> UCACHE_SEMLOCK = <NUM_LIT:0> <EOL> LEN_FRIEND_EXP = <NUM_LIT:15> <EOL> REFRESH_TIME = <NUM_LIT:30> <EOL> USER_TITLE_LEN = <NUM_LIT> <EOL> SESSION_TIMEOUT = datetime . timedelta ( <NUM_LIT:30> ) <EOL> SESSION_TIMEOUT_SECONDS = <NUM_LIT> * <NUM_LIT:30> <EOL> XMPP_IDLE_TIME = <NUM_LIT> <EOL> XMPP_LONG_IDLE_TIME = <NUM_LIT> <EOL> XMPP_UPDATE_TIME_INTERVAL = <NUM_LIT:10> <EOL> XMPP_PING_TIME_INTERVAL = <NUM_LIT> <EOL> PUBLIC_SHMKEY = <NUM_LIT> <EOL> MAX_ATTACHSIZE = <NUM_LIT:20> * <NUM_LIT> * <NUM_LIT> <EOL> BMDEL_DECREASE = True <EOL> SYSMAIL_BOARD = "<STR_LIT>" <EOL> ADD_EDITMARK = True <EOL> SEARCH_COUNT_LIMIT = <NUM_LIT:20> <EOL> MAIL_SIZE_LIMIT = - <NUM_LIT:1> <EOL> SEC_DELETED_OLDHOME = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:3> <EOL> SELF_INTRO_MAX_LEN = <NUM_LIT> </s>
<s> import re <EOL> import os <EOL> import stat <EOL> import json <EOL> import struct <EOL> import time <EOL> import Config <EOL> import Board <EOL> import Post <EOL> import BoardManager <EOL> from Util import Util <EOL> from Log import Log <EOL> from errors import * <EOL> DEFAULT_DIGEST_LIST_COUNT = <NUM_LIT:20> <EOL> class DigestItem : <EOL> def __init__ ( self , basepath ) : <EOL> self . basepath = basepath <EOL> self . title = '<STR_LIT>' <EOL> self . host = '<STR_LIT>' <EOL> self . port = <NUM_LIT:0> <EOL> self . attachpos = <NUM_LIT:0> <EOL> self . fname = '<STR_LIT>' <EOL> self . mtitle = '<STR_LIT>' <EOL> self . items = [ ] <EOL> self . update_time = <NUM_LIT:0> <EOL> self . id = <NUM_LIT:0> <EOL> self . sysop_only = <NUM_LIT:0> <EOL> self . bms_only = <NUM_LIT:0> <EOL> self . zixia_only = <NUM_LIT:0> <EOL> def IsDir ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISDIR ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def IsFile ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISREG ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def GetModTime ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> mtime = st . st_mtime <EOL> except : <EOL> mtime = time . time ( ) <EOL> return mtime <EOL> def names_path ( self ) : <EOL> return "<STR_LIT>" % self . realpath ( ) <EOL> def realpath ( self ) : <EOL> return "<STR_LIT>" % ( Config . BBS_ROOT , self . path ( ) ) <EOL> def path ( self ) : <EOL> if ( self . fname ) : <EOL> return "<STR_LIT>" % ( self . basepath , self . fname ) <EOL> else : <EOL> return self . basepath <EOL> def CheckUpdate ( self ) : <EOL> try : <EOL> stat = os . stat ( self . names_path ( ) ) <EOL> if ( stat . st_mtime > self . update_time ) : <EOL> self . LoadNames ( ) <EOL> except : <EOL> return False <EOL> return True <EOL> def LoadNames ( self ) : <EOL> try : <EOL> f = open ( self . names_path ( ) , "<STR_LIT:r>" ) <EOL> except IOError : <EOL> return <NUM_LIT:0> <EOL> stat = os . fstat ( f . fileno ( ) ) <EOL> self . update_time = stat . st_mtime <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> _id = <NUM_LIT:0> <EOL> bms_only = <NUM_LIT:0> <EOL> sysop_only = <NUM_LIT:0> <EOL> zixia_only = <NUM_LIT:0> <EOL> while ( True ) : <EOL> line = f . readline ( ) <EOL> if ( line == "<STR_LIT>" ) : break <EOL> npos = line . find ( "<STR_LIT:\n>" ) <EOL> if ( npos != - <NUM_LIT:1> ) : line = line [ : npos ] <EOL> if ( line [ : <NUM_LIT:1> ] == '<STR_LIT:#>' ) : <EOL> if ( line [ : <NUM_LIT:8> ] == "<STR_LIT>" ) : <EOL> if ( not self . mtitle ) : <EOL> self . mtitle = line [ <NUM_LIT:8> : ] <EOL> result = re . match ( '<STR_LIT>' , line ) <EOL> if ( result ) : <EOL> key = result . group ( <NUM_LIT:1> ) <EOL> value = result . group ( <NUM_LIT:2> ) <EOL> if ( key == "<STR_LIT:Name>" ) : <EOL> item . title = value <EOL> item . attachpos = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> if ( value [ : <NUM_LIT:2> ] == "<STR_LIT>" ) : <EOL> item . fname = value [ <NUM_LIT:2> : ] <EOL> else : <EOL> item . fname = value <EOL> if ( item . fname . find ( "<STR_LIT:..>" ) != - <NUM_LIT:1> ) : <EOL> continue <EOL> if ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> bms_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> sysop_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> zixia_only += <NUM_LIT:1> <EOL> if ( item . fname . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> parts = re . split ( '<STR_LIT>' , item . fname ) <EOL> newparts = [ ] <EOL> for part in parts : <EOL> if ( part ) : <EOL> newparts += [ part ] <EOL> hostname = newparts [ <NUM_LIT:0> ] <EOL> item . fname = newparts [ <NUM_LIT:1> ] <EOL> try : <EOL> item . port = int ( newparts [ <NUM_LIT:2> ] ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> item . id = _id <EOL> _id += <NUM_LIT:1> <EOL> item . bms_only = bms_only <EOL> item . sysop_only = sysop_only <EOL> item . zixia_only = zixia_only <EOL> item . host = hostname <EOL> self . items += [ item ] <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> elif ( key == "<STR_LIT>" ) : <EOL> hostname = value <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . port = int ( value ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . attachpos = int ( value ) <EOL> except : <EOL> item . attachpos = <NUM_LIT:0> <EOL> f . close ( ) <EOL> return <NUM_LIT:1> <EOL> def GetItem ( self , user , route , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> if ( Board . Board . IsBM ( user , self . mtitle [ <NUM_LIT:4> : ] , ) or user . IsSysop ( ) ) : <EOL> has_perm = True <EOL> elif ( need_perm and not has_perm ) : <EOL> return None <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> need_perm = True <EOL> if ( len ( route ) == <NUM_LIT:0> ) : <EOL> return self <EOL> target = route [ <NUM_LIT:0> ] - <NUM_LIT:1> <EOL> _id = target <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> while ( self . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> item = self . items [ _id ] <EOL> item . mtitle = item . title <EOL> if ( len ( route ) == <NUM_LIT:1> ) : <EOL> return item <EOL> else : <EOL> if ( item . IsDir ( ) ) : <EOL> if ( not item . CheckUpdate ( ) ) : <EOL> return None <EOL> return item . GetItem ( user , route [ <NUM_LIT:1> : ] , has_perm , need_perm ) <EOL> else : <EOL> return None <EOL> def GetRange ( self , user , route , start , end , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> firstitem = self . GetItem ( user , route + [ start ] , has_perm , need_perm ) <EOL> if ( not firstitem ) : <EOL> return [ ] <EOL> parent = self . GetItem ( user , route , has_perm , need_perm ) <EOL> if ( not parent ) : <EOL> return [ ] <EOL> if ( not parent . IsDir ( ) ) : <EOL> return [ ] <EOL> result = [ ] <EOL> _id = start - <NUM_LIT:1> <EOL> for i in range ( start , end + <NUM_LIT:1> ) : <EOL> target = i - <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return [ ] <EOL> while ( parent . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return result <EOL> item = parent . items [ _id ] <EOL> item . mtitle = item . title <EOL> result += [ item ] <EOL> return result <EOL> def EffectiveId ( self , user ) : <EOL> _id = self . id <EOL> if ( user . IsSysop ( ) ) : <EOL> return _id <EOL> if ( not user . IsSysop ( ) ) : <EOL> _id -= self . sysop_only <EOL> if ( not user . IsBM ( ) ) : <EOL> _id -= self . bms_only <EOL> if ( not user . IsSECANC ( ) ) : <EOL> _id -= self . zixia_only <EOL> return _id <EOL> def GetInfo ( self ) : <EOL> info = { } <EOL> info [ '<STR_LIT>' ] = Util . gbkDec ( self . mtitle ) <EOL> info [ '<STR_LIT:title>' ] = Util . gbkDec ( self . title ) <EOL> info [ '<STR_LIT>' ] = self . attachpos <EOL> if ( self . host != '<STR_LIT>' ) : <EOL> info [ '<STR_LIT:host>' ] = self . host <EOL> info [ '<STR_LIT:port>' ] = self . port <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsDir ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsFile ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT:file>' <EOL> else : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> info [ '<STR_LIT>' ] = int ( self . GetModTime ( ) ) <EOL> return info <EOL> def GetInfoForUser ( self , user ) : <EOL> info = self . GetInfo ( ) <EOL> info [ '<STR_LIT:id>' ] = self . EffectiveId ( user ) + <NUM_LIT:1> <EOL> return info <EOL> def GetAttachLink ( self , session ) : <EOL> _hash = Util . HashGen ( self . path ( ) , "<STR_LIT>" ) <EOL> filename = '<STR_LIT>' <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> filename += "<STR_LIT>" % struct . unpack ( '<STR_LIT>' , _hash [ i * <NUM_LIT:4> : ( i + <NUM_LIT:1> ) * <NUM_LIT:4> ] ) <EOL> link = "<STR_LIT>" % ( session . GetMirror ( Config . Config . GetInt ( '<STR_LIT>' , <NUM_LIT> ) ) , filename ) <EOL> linkfile = "<STR_LIT>" % ( Config . BBS_ROOT , filename ) <EOL> target = "<STR_LIT>" % self . path ( ) <EOL> try : <EOL> os . symlink ( target , linkfile ) <EOL> except : <EOL> pass <EOL> return link <EOL> class Digest : <EOL> root = DigestItem ( "<STR_LIT>" ) <EOL> def __init__ ( self , board , path ) : <EOL> self . board = board <EOL> self . path = path <EOL> self . root = DigestItem ( self . path ) <EOL> @ staticmethod <EOL> def GET ( svc , session , params , action ) : <EOL> if ( session is None ) : raise Unauthorized ( '<STR_LIT>' ) <EOL> if not session . CheckScope ( '<STR_LIT>' ) : raise NoPerm ( "<STR_LIT>" ) <EOL> user = session . GetUser ( ) <EOL> boardname = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if ( boardname ) : <EOL> board = BoardManager . BoardManager . GetBoard ( boardname ) <EOL> if ( board is None ) : raise NotFound ( '<STR_LIT>' % boardname ) <EOL> if ( not board . CheckReadPerm ( user ) ) : <EOL> raise NoPerm ( '<STR_LIT>' ) <EOL> basenode = board . digest . root <EOL> has_perm = user . IsDigestMgr ( ) or user . IsSysop ( ) or user . IsSuperBM ( ) <EOL> else : <EOL> basenode = Digest . root <EOL> has_perm = user . IsDigestMgr ( ) <EOL> if ( action == "<STR_LIT:list>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:1> ) <EOL> end = svc . get_int ( params , '<STR_LIT:end>' , start + DEFAULT_DIGEST_LIST_COUNT - <NUM_LIT:1> ) <EOL> Digest . List ( svc , basenode , route , start , end , session , has_perm ) <EOL> return <EOL> elif ( action == "<STR_LIT>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:0> ) <EOL> count = svc . get_int ( params , '<STR_LIT:count>' , <NUM_LIT:0> ) <EOL> Digest . View ( svc , basenode , route , session , has_perm , start , count ) <EOL> return <EOL> else : <EOL> raise WrongArgs ( '<STR_LIT>' % action ) <EOL> @ staticmethod <EOL> def ParseRoute ( route ) : <EOL> ret = [ ] <EOL> items = re . split ( '<STR_LIT:->' , route ) <EOL> items = items [ <NUM_LIT:1> : ] <EOL> for item in items : <EOL> try : <EOL> ret += [ int ( item ) ] <EOL> except : <EOL> raise WrongArgs ( '<STR_LIT>' % item ) <EOL> return ret <EOL> @ staticmethod <EOL> def List ( svc , basenode , route , start , end , session , has_perm ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> parent = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not parent ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not parent . IsDir ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> items = basenode . GetRange ( session . GetUser ( ) , route_array , start , end , has_perm ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = parent . GetInfoForUser ( session . GetUser ( ) ) <EOL> result [ '<STR_LIT:count>' ] = len ( items ) <EOL> result_list = [ ] <EOL> for item in items : <EOL> result_list += [ item . GetInfoForUser ( session . GetUser ( ) ) ] <EOL> result [ '<STR_LIT>' ] = result_list <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> @ staticmethod <EOL> def View ( svc , basenode , route , session , has_perm , start , count ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> item = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not item ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not item . IsFile ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = item . GetInfoForUser ( session . GetUser ( ) ) <EOL> postinfo = Post . Post ( item . realpath ( ) , None ) <EOL> ( result [ '<STR_LIT:content>' ] , result [ '<STR_LIT>' ] ) = postinfo . GetContent ( start , count ) <EOL> attachlist = postinfo . GetAttachListByType ( ) <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:0> ] <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:1> ] <EOL> if ( attachlist [ <NUM_LIT:0> ] or attachlist [ <NUM_LIT:1> ] ) : <EOL> result [ '<STR_LIT>' ] = item . GetAttachLink ( session ) <EOL> svc . writedata ( json . dumps ( result ) ) </s>
<s> import time <EOL> import UserManager <EOL> import UserInfo <EOL> from Session import Session <EOL> from Log import Log <EOL> import UCache <EOL> import Config <EOL> import MsgBox <EOL> import xmpp <EOL> import modes <EOL> import Util <EOL> import traceback <EOL> import os <EOL> from xmpp . features import NoRoute <EOL> __disco_info_ns__ = '<STR_LIT>' <EOL> __disco_items_ns__ = '<STR_LIT>' <EOL> __vcard_ns__ = '<STR_LIT>' <EOL> STEAL_AFTER_SEEN = <NUM_LIT:3> <EOL> def elem_to_str ( elem ) : <EOL> return "<STR_LIT>" % ( elem . tag , elem . attrib , elem . text ) <EOL> class XMPPServer ( xmpp . Plugin ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , rosters , host ) : <EOL> self . probed = False <EOL> self . _closed = False <EOL> self . rosters = rosters <EOL> self . _session = None <EOL> self . rosters . set_resources ( self . get_resources ( ) ) <EOL> self . _fixedjid = UCache . UCache . formalize_jid ( unicode ( self . authJID ) ) <EOL> self . _userid = self . _fixedjid . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] . encode ( "<STR_LIT>" ) <EOL> if ( not self . rosters . allow_login ( self . authJID . bare ) ) : <EOL> Log . warn ( "<STR_LIT>" % self . _userid ) <EOL> self . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> return <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if self . authJID . resource [ : - <NUM_LIT:8> ] != "<STR_LIT>" and len ( self . authJID . resource ) > <NUM_LIT:8> : <EOL> try : <EOL> routes = self . routes ( self . authJID . bare ) <EOL> for route in routes : <EOL> jid = route [ <NUM_LIT:0> ] <EOL> if jid . resource [ : - <NUM_LIT:8> ] == self . authJID . resource [ : - <NUM_LIT:8> ] : <EOL> if jid . resource != self . authJID . resource : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> route [ <NUM_LIT:1> ] . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> except NoRoute : <EOL> pass <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> self . _user = UserManager . UserManager . LoadUser ( self . _userid ) <EOL> if ( self . _user == None ) : <EOL> raise Exception ( "<STR_LIT>" ) <EOL> self . _peer_addr = self . getpeername ( ) <EOL> self . _session = Session ( self . _user , self . _peer_addr [ <NUM_LIT:0> ] ) <EOL> self . _session . RecordLogin ( ) <EOL> self . _userinfo = self . _session . Register ( ) <EOL> self . _loginid = self . _session . utmpent <EOL> self . _hostname = host <EOL> self . bind ( xmpp . ReceivedCloseStream , self . recv_close ) <EOL> self . bind ( xmpp . StreamClosed , self . stream_closed ) <EOL> self . bind ( xmpp . SentCloseStream , self . sent_close ) <EOL> self . rosters . register_conn ( self ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> if self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) is None : <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msgbox . GetMsgCount ( all = False ) - msgbox . GetUnreadCount ( ) ) <EOL> self . check_msg ( ) <EOL> def get_loginid ( self ) : <EOL> return self . _loginid <EOL> def recv_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def stream_closed ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def sent_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def close ( self ) : <EOL> if ( self . _closed ) : <EOL> Log . debug ( "<STR_LIT>" ) <EOL> return <EOL> self . _closed = True <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if ( self . _session ) : <EOL> self . _session . Unregister ( ) <EOL> self . unbind_res ( ) <EOL> self . rosters . unregister_conn ( self ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def ping ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> self . refresh ( ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> @ xmpp . stanza ( '<STR_LIT:message>' ) <EOL> def message ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> to_jid = elem . get ( '<STR_LIT:to>' ) <EOL> from_jid = elem . get ( '<STR_LIT>' ) <EOL> if ( from_jid == None ) : <EOL> return <EOL> text_body = None <EOL> for child in elem : <EOL> if ( child . tag . endswith ( '<STR_LIT>' ) ) : <EOL> text_body = child . text <EOL> if ( text_body == None ) : <EOL> return <EOL> ret = self . rosters . send_msg ( from_jid , to_jid , text_body ) <EOL> if ( ret <= <NUM_LIT:0> ) : <EOL> Log . warn ( "<STR_LIT>" % ( to_jid , from_jid , ret ) ) <EOL> errors = { <EOL> - <NUM_LIT:1> : "<STR_LIT>" , <EOL> - <NUM_LIT:11> : "<STR_LIT>" , <EOL> - <NUM_LIT:12> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT:2> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" } <EOL> if ( ret in errors ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : to_jid , <EOL> '<STR_LIT:to>' : from_jid , <EOL> '<STR_LIT:type>' : '<STR_LIT:error>' } , <EOL> self . E . body ( errors [ ret ] ) ) <EOL> self . recv ( from_jid , elem ) <EOL> def make_jid ( self , userid ) : <EOL> return "<STR_LIT>" % ( userid , self . _hostname ) <EOL> def refresh ( self ) : <EOL> self . _userinfo . freshtime = int ( time . time ( ) ) <EOL> self . _userinfo . save ( ) <EOL> def ping_result ( self , iq ) : <EOL> self . refresh ( ) <EOL> def ping_client ( self ) : <EOL> try : <EOL> pingelem = self . E . ping ( xmlns = '<STR_LIT>' ) <EOL> return self . iq ( '<STR_LIT>' , self . ping_result , pingelem ) <EOL> except Exception as e : <EOL> Log . debug ( "<STR_LIT>" % ( self . authJID , e ) ) <EOL> Log . debug ( traceback . format_exc ( ) ) <EOL> return False <EOL> def get_uid ( self ) : <EOL> return self . _user . GetUID ( ) <EOL> def recv_msg ( self , from_ , msgtext ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : from_ , '<STR_LIT:to>' : unicode ( self . authJID ) } , <EOL> self . E . body ( msgtext ) ) <EOL> self . recv ( unicode ( self . authJID ) , elem ) <EOL> def check_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> xmpp_read = self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) <EOL> if xmpp_read > msg_count : <EOL> xmpp_read = <NUM_LIT:0> <EOL> Log . debug ( "<STR_LIT>" % ( msg_count , xmpp_read ) ) <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msg_count ) <EOL> if xmpp_read < msg_count : <EOL> return xmpp_read <EOL> else : <EOL> return - <NUM_LIT:1> <EOL> def deliver_msg ( self , start ) : <EOL> Log . debug ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> for i in range ( start , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> def steal_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> msg_unread = msgbox . GetUnreadCount ( ) <EOL> read_count = msg_count - msg_unread <EOL> my_pid = os . getpid ( ) <EOL> term_read = self . rosters . get_term_read ( self . get_uid ( ) ) <EOL> term_stealed = self . rosters . get_term_stealed ( self . get_uid ( ) ) <EOL> all_xmpp = True <EOL> new_unread = { } <EOL> for i in range ( read_count - <NUM_LIT:1> , msg_count ) : <EOL> if i < <NUM_LIT:0> : <EOL> continue <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if i >= read_count and all_xmpp : <EOL> if msghead . topid == my_pid : <EOL> msgbox . GetUnreadMsg ( ) <EOL> else : <EOL> all_xmpp = False <EOL> if msghead . topid == my_pid : <EOL> continue <EOL> if i < read_count : <EOL> session = self . rosters . find_session ( self . authJID . bare , msghead . topid ) <EOL> if session is None or session . get_mode ( ) != modes . MSG : <EOL> continue <EOL> Log . debug ( "<STR_LIT>" % i ) <EOL> if msghead . topid not in new_unread : <EOL> Log . debug ( "<STR_LIT>" % ( msghead . topid , i ) ) <EOL> new_unread [ msghead . topid ] = i <EOL> final_unread = { } <EOL> to_steal = { } <EOL> to_steal_begin = msg_count <EOL> for pid in term_read : <EOL> if pid in new_unread : <EOL> if new_unread [ pid ] == term_read [ pid ] [ <NUM_LIT:0> ] : <EOL> final_unread [ pid ] = ( term_read [ pid ] [ <NUM_LIT:0> ] , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) ) <EOL> if final_unread [ pid ] [ <NUM_LIT:1> ] > STEAL_AFTER_SEEN : <EOL> to_steal [ pid ] = final_unread [ pid ] <EOL> Log . debug ( "<STR_LIT>" % ( to_steal [ pid ] [ <NUM_LIT:0> ] , pid ) ) <EOL> if pid in term_stealed : <EOL> steal_begin = max ( final_unread [ pid ] [ <NUM_LIT:0> ] , term_stealed [ pid ] + <NUM_LIT:1> ) <EOL> else : <EOL> steal_begin = final_unread [ pid ] [ <NUM_LIT:0> ] <EOL> if steal_begin < to_steal_begin : <EOL> to_steal_begin = steal_begin <EOL> else : <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( term_read [ pid ] [ <NUM_LIT:0> ] , new_unread [ pid ] , pid ) ) <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % pid ) <EOL> pass <EOL> for pid in new_unread : <EOL> if pid not in term_read : <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid ) ) <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> if to_steal : <EOL> Log . debug ( "<STR_LIT>" % to_steal_begin ) <EOL> for i in range ( to_steal_begin , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgbox . GetUnreadMsg ( ) <EOL> elif msghead . topid in to_steal : <EOL> if msghead . topid not in term_stealed or i > term_stealed [ msghead . topid ] : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> term_stealed [ msghead . topid ] = i <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> self . rosters . set_term_read ( self . get_uid ( ) , final_unread ) <EOL> @ xmpp . stanza ( '<STR_LIT>' ) <EOL> def presence ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if self . authJID == elem . get ( '<STR_LIT>' ) : <EOL> if ( elem . get ( '<STR_LIT:to>' ) == None or ( not self . authJID . match_bare ( elem . get ( '<STR_LIT:to>' ) ) ) ) : <EOL> return self . send_presence ( elem ) <EOL> self . recv_presence ( elem ) <EOL> def send_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> direct = elem . get ( '<STR_LIT:to>' ) <EOL> if not direct : <EOL> self . rosters . broadcast ( self , elem ) <EOL> if elem . get ( '<STR_LIT:type>' ) != '<STR_LIT>' : <EOL> self . recv_presence ( elem ) <EOL> if not self . probed : <EOL> self . probed = True <EOL> self . rosters . probe ( self ) <EOL> elif not self . rosters . send ( self , direct , elem ) : <EOL> self . send ( direct , elem ) <EOL> def recv_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if not self . rosters . recv ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> self . write ( elem ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def roster ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> roster = self . rosters . get ( self ) <EOL> method = getattr ( self , '<STR_LIT>' % iq . get ( '<STR_LIT:type>' ) ) <EOL> return method and method ( iq , roster ) <EOL> def get_roster ( self , iq , roster ) : <EOL> query = self . E . query ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> for item in roster . items ( ) : <EOL> query . append ( item ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query ) <EOL> def set_roster ( self , iq , roster ) : <EOL> query = self . E . query ( xmlns = '<STR_LIT>' ) <EOL> for item in iq [ <NUM_LIT:0> ] : <EOL> result = roster . set ( item ) <EOL> if result is not None : <EOL> query . append ( result ) <EOL> if len ( query ) > <NUM_LIT:0> : <EOL> self . push ( roster , query ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> def push ( self , roster , query ) : <EOL> """<STR_LIT>""" <EOL> for jid in roster . requests ( ) : <EOL> for ( to , route ) in self . routes ( jid ) : <EOL> route . iq ( '<STR_LIT>' , self . ignore , query ) <EOL> def ignore ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def vcard ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> if iq . get ( '<STR_LIT:type>' ) == '<STR_LIT>' : <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> target = iq . get ( '<STR_LIT>' ) <EOL> else : <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> form_target = UCache . UCache . formalize_jid ( target ) <EOL> name = form_target . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] <EOL> user = UserManager . UserManager . LoadUser ( name ) <EOL> info = user . GetInfo ( ) <EOL> desc = '''<STR_LIT>''' % ( info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , <EOL> info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] ) <EOL> if ( '<STR_LIT>' in info ) : <EOL> desc += "<STR_LIT>" % ( info [ '<STR_LIT>' ] . replace ( '<STR_LIT:\n>' , '<STR_LIT:\r\n>' ) ) <EOL> vcard = self . E . vCard ( { '<STR_LIT>' : '<STR_LIT>' } , <EOL> self . E ( '<STR_LIT>' , name ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( info [ '<STR_LIT>' ] ) ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( desc ) ) ) <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard ) <EOL> else : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard , { '<STR_LIT>' : iq . get ( '<STR_LIT:to>' ) } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_info_ns__ ) <EOL> def disco_info ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_items_ns__ ) <EOL> def disco_items ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> import json <EOL> from hpOneView . common import uri <EOL> import hpOneView . profile as profile <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_eg_uri_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> egs = srv . get_enclosure_groups ( ) <EOL> for eg in egs : <EOL> if eg [ '<STR_LIT:name>' ] == name : <EOL> return eg [ '<STR_LIT>' ] <EOL> return None <EOL> def get_sht_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> shts = srv . get_server_hardware_types ( ) <EOL> for sht in shts : <EOL> if sht [ '<STR_LIT:name>' ] == name : <EOL> return sht <EOL> return None <EOL> def define_profile_template ( <EOL> srv , <EOL> name , <EOL> desc , <EOL> sp_desc , <EOL> server_hwt , <EOL> enc_group , <EOL> affinity , <EOL> hide_flexnics , <EOL> conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) : <EOL> if conn_list : <EOL> conn = json . loads ( open ( conn_list ) . read ( ) ) <EOL> else : <EOL> conn = [ ] <EOL> profile_template = srv . create_server_profile_template ( <EOL> name = name , <EOL> description = desc , <EOL> serverProfileDescription = sp_desc , <EOL> serverHardwareTypeUri = server_hwt , <EOL> enclosureGroupUri = enc_group , <EOL> affinity = affinity , <EOL> hideUnusedFlexNics = hide_flexnics , <EOL> profileConnectionV4 = conn , <EOL> firmwareSettingsV3 = fw_settings , <EOL> bootSettings = boot , <EOL> bootModeSetting = bootmode ) <EOL> if '<STR_LIT>' in profile_template : <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:type>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:description>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> for connection in profile_template [ '<STR_LIT>' ] : <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] , '<STR_LIT:\n>' ) <EOL> else : <EOL> pprint ( profile_template ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:name>' , <EOL> required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT:true>' , '<STR_LIT:false>' ] , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> nargs = '<STR_LIT:+>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> sts = hpov . settings ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> eg_uri = get_eg_uri_from_arg ( srv , args . enc_group ) <EOL> sht = get_sht_from_arg ( srv , args . server_hwt ) <EOL> fw_settings = profile . make_firmware_dict ( sts , args . baseline ) <EOL> boot , bootmode = profile . make_boot_settings_dict ( srv , sht , args . disable_manage_boot , <EOL> args . boot_order , args . boot_mode , args . pxe ) <EOL> define_profile_template ( srv , <EOL> args . name , <EOL> args . desc , <EOL> args . sp_desc , <EOL> sht [ '<STR_LIT>' ] , <EOL> eg_uri , <EOL> args . affinity , <EOL> args . hide_flexnics , <EOL> args . conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( "<STR_LIT>" ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_address_pools ( con , srv , types ) : <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vmac = srv . get_vmac_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vmac ) : <EOL> print ( '<STR_LIT>' . format ( key , vmac [ key ] ) ) <EOL> if '<STR_LIT>' in vmac : <EOL> for uri in vmac [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vwwn = srv . get_vwwn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vwwn ) : <EOL> print ( '<STR_LIT>' . format ( key , vwwn [ key ] ) ) <EOL> if '<STR_LIT>' in vwwn : <EOL> for uri in vwwn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vsn = srv . get_vsn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vsn ) : <EOL> print ( '<STR_LIT>' . format ( key , vsn [ key ] ) ) <EOL> if '<STR_LIT>' in vsn : <EOL> for uri in vsn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_address_pools ( con , srv , args . types ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> import re <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_managed_sans ( fcs ) : <EOL> sans = fcs . get_managed_sans ( ) <EOL> pprint ( sans ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> fcs = hpov . fcsans ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_managed_sans ( fcs ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
